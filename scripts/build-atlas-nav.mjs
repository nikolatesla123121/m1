#!/usr/bin/env node
import fs from 'fs/promises';
import path from 'path';

const root = process.cwd();

function fileExists(p){
  return fs.stat(p).then(()=>true).catch(()=>false);
}

function normalizeHref(href){
  // Strip query/hash
  href = href.split(/[?#]/)[0];
  if (!href.startsWith('/')) href = '/' + href;
  if (href.endsWith('/')) href = href + 'index.html';
  // If already points to html, keep
  return href;
}

async function extractFromFile(filePath, prefix = ''){
  const content = await fs.readFile(filePath, 'utf8');
  const idx = content.indexOf('<section class="grid"');
  if (idx === -1) return [];
  const endIdx = content.indexOf('</section>', idx);
  if (endIdx === -1) return [];
  const section = content.slice(idx, endIdx);
  const re = /<a\s+[^>]*href=("|')([^"']+)\1/ig;
  const hrefs = [];
  const seen = new Set();
  let m;
  while ((m = re.exec(section)) !== null){
    let href = m[2].trim();
    if (!href || href.startsWith('http') || href.startsWith('#') || href.startsWith('mailto:')) continue;
    // Resolve relative hrefs against prefix
    let combined = href;
    // If href starts with '/', it's already absolute in site root
    if (combined.startsWith('/')) combined = combined.slice(1);
    if (prefix) combined = path.posix.join(prefix, combined);
    let norm = normalizeHref(combined);
    // Remove duplicate
    if (seen.has(norm)) continue;
    // Verify file exists in repo
    const candidateFsPath = path.join(root, norm.replace(/^?\//, ''));
    const exists = await fileExists(candidateFsPath);
    if (!exists) {
      // try without index.html (maybe link points to a directory with index.html elsewhere)
      const alt = norm.replace(/index\.html$/, '');
      const altFs = path.join(root, alt.replace(/^\//,''));
      if (await fileExists(path.join(root, alt.replace(/^\//,'')))) {
        // OK, accept the directory form
        norm = alt; // keep ending slash removed
      } else {
        // skip missing target
        // console.warn('Skipping non-existing target:', norm, ' (from ', filePath, ')');
        continue;
      }
    }
    seen.add(norm);
    hrefs.push(norm);
  }
  return hrefs;
}

(async function main(){
  try{
    const trAtlas = path.join(root, 'atlas.html');
    const enAtlas = path.join(root, 'eng', 'atlas.html');

    const atlasTR = (await fileExists(trAtlas)) ? await extractFromFile(trAtlas, '') : [];
    const atlasEN_fromFile = (await fileExists(enAtlas)) ? await extractFromFile(enAtlas, 'eng') : null;

    let atlasEN = [];
    if (atlasEN_fromFile && atlasEN_fromFile.length) {
      atlasEN = atlasEN_fromFile.map(p => p.startsWith('/') ? p : '/' + p);
    } else {
      // derive EN by mapping TR -> /eng/ paths when they exist
      for (const p of atlasTR){
        // p starts with /
        const rel = p.replace(/^\//, '');
        const engPath = path.posix.join('/eng', rel);
        const engFsPath = path.join(root, engPath.replace(/^\//,''));
        if (await fileExists(engFsPath)) atlasEN.push(engPath);
      }
    }

    // Ensure arrays are normalized (leading slash, consistent index.html ending where possible)
    const normalizeOut = (arr) => arr.map(x => {
      if (!x.startsWith('/')) x = '/' + x;
      return x;
    });

    const outTR = normalizeOut(atlasTR);
    const outEN = normalizeOut(atlasEN);

    const targetDir = path.join(root, 'assets', 'data');
    await fs.mkdir(targetDir, { recursive: true });

    const filePath = path.join(targetDir, 'atlas-pages.generated.js');
    const now = new Date().toISOString();
    const content = `// Generated by scripts/build-atlas-nav.mjs at ${now}\n// DO NOT EDIT - this file is auto-generated\n\nexport const atlasTR = ${JSON.stringify(outTR, null, 2)};\n\nexport const atlasEN = ${JSON.stringify(outEN, null, 2)};\n`;

    await fs.writeFile(filePath, content, 'utf8');
    console.log('Wrote', filePath);
    console.log('TR entries:', outTR.length, 'EN entries:', outEN.length);
  } catch (err){
    console.error('Failed to build atlas nav', err);
    process.exit(1);
  }
})();
